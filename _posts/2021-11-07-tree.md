---
title : "Tree"
categories : 
    - Data Structure
tag :
    - [Tree, BFS, DFS, Binary Tree, Complete Binary Tree, Binary Search Tree]  # [C, python]
author_profile: false
sidebar:
    nav: "docs"
use_math: true
toc: true # 목차
toc_sticky: true
toc_label: "On This Page"
---

## What is a tree?
Tree as a kind of graph and data structure representing hierarchical relationships between data.

### Tree related terms

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140644799-c82f6d93-bd90-471a-9d80-820c49f1d54a.png">

* root : Node on the top of the tree
* leaf(terminal node/external node) : Last node that can no longer stretch out
* internal node(non-terminal node) : Node except leaf and root
* child : Lower node branched from the node(child of B node is D node)
* parent : Upper node branched from the child node(parent of D node is B node)
* sibling : Nodes have same parent(D, E node)
* height : Distance from the root to the furthest leaf
* level : Height away from the root
* degree : The number of child a node has, n-nary if all nodes are of degree n or less(The tree above is a binary tree)
* sub tree : Which node in the tree is again set as the root, 
tree of its child(Triangle is sub tree that B node as root)
* ancestor : Upper all nodes branched from the any node
* descendant : Lower all nodes branched from the any node
* null tree : Tree without node and branch
* ordered tree : Care about having order of sibling nodes
* unordered tree : Don't Care about having order of sibling nodes

In an ordered tree, a and b are different, but in an unordered tree, they are the same.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140680793-0716c5fb-1d8a-4176-8f1e-6c1337186a76.png">

<br/>

## BFS(Breadth-Fist Search)
A search method that start at low level and search node from left to right and move on to the next level when the search is complete.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140916284-e1d3b7a6-a71e-4321-a737-955841074e79.png">

<br/>

## DFS(Depth-Fist Search)
A search method that prioritizes searching down to the leaf. When the leaf is reached and there is nowhere else to proceed with the search, it returns to the parent.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140915257-d3ef32ae-f97c-4a9b-94cf-54c716182ddf.png">

<br/>

## Tree Traversal
There are three main ways to explore data in depth-first search.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140739580-5e04cf4b-015a-4283-a5d2-4e7005e6ff45.png">

### Preorder Traversal
1. Visit the root
2. Traverse the left subtree
3. Traverse the right subtree

* Visit order  
`A >> B >> D >> H >> I >> E >> J >> K >> C >> F >> L >> N >> G >> M >> O`

### Inorder Traversal
1. Traverse the left subtree
2. Visit the root
3. Traverse the right subtree

* Visit order  
`H >> D >> I >> B >> J >> E >> K >> A >> L >> F >> N >> C >> M >> G >> O`

### Postorder Traversal
1. Traverse the left subtree
2. Traverse the right subtree
3. Visit the root

* Visit order  
`H >> I >> D >> J >> K >> E >> B >> L >> N >> F >> M >> O >> G >> C >> A`

<br/>

## Binary Tree
Binary tree has left, right child and less than two child. It is a data structure used to increase the speed of data search. Unlike a complete binary tree, a binary tree is difficult to express as an array, so pointers are needed to point to the left and right child.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140921239-c8bd647c-f426-4289-9f33-31de41c8ca29.png">

<br/>

## Complete Binary Tree
 Tree in which nodes are filled from the root and nodes are filled from left to right at the same level. As shown in the picture below, if 0,1,2 is given to each node, it corresponds to the index of the array in a one-to-one so it used for heap sort.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140921231-b5a9a801-bd40-46f0-962b-17f307ab2ce8.png">

<br/>

## Binary Search Tree
Binary search tree is binary tree needs to satisfy the following conditions.

* condition
1. Based on some node N, all key values ​​of the left sub tree node must be less than the key values ​​of node N.
2. The key value of the right sub tree node must be greater than the key value of node N.
3. There should be no nodes with the same key value.

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/140921249-34b157b7-0c3a-4748-83b8-d2b245311591.png">

<span style='background-color: #dcffe4'>Inorder traversal of a binary search tree, can get nodes in ascending order of key values.</span> 

* Visit order  
`1 >> 3 >> 5 >> 6 >> 7 >> 9 >> 10 >> 11 >> 12 >> 13 >> 15 >> 16`

Binary search tree can obtain nodes in ascending order of key values ​​by inorder traversal, search is possible in a similar way to binary search, and insertion of nodes is easy. Therefore, binary search trees are widely used.

<br/>

## Create Binary Searh Tree

### Main Function
#### Node Structure
Node structure in a binary search tree that are self referential structure, has left and right child nodes.

```c
/*--- Node ---*/
typedef struct __binnode {
	Member data;			/* data */
	struct __bnode *left;	/* left child node pointer */
	struct __bnode *right;	/* right child node pointer */
} BinNode;
```

---
#### Create Node
Create node type object in binary search tree.
```c
/*--- Allocate node dynamically ---*/
static BinNode *AllocBinNode(void)
{
	return calloc(1, sizeof(BinNode));
}
```

---

#### Set member of node
Set value for member for node pointed to by parameter `n`.

```c
/*--- Set member of node ----*/
static void SetBinNode(BinNode *n, const Member *x, const BinNode *left, const BinNode *right)
{
	n->data = *x;			/* data */
	n->left = left;			/* left pointer */
	n->right = right;		/* right pointer */
}
```

---

#### Search by key value of node
Start search from root, seleccted node is `p`.
Searching value is key and compare node `p` with key value under the following conditions.

**Search is successful**

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/141283284-4c88653b-5cf2-454f-967d-3c8d0b46da53.png">

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/141283299-66242a67-db67-4677-98d6-b2411ecbaf9f.png">

---

**Search is fail**

<img width="800" alt="computer_inside" src="https://user-images.githubusercontent.com/92430498/141284049-ef12ba4c-ba92-487f-8c1c-b4a6ebcd13b7.png">

---

* Conditional processing
    1. If selected node(`p`) is NULL, search fail.
    2. Match the value : Search sucess and return selected node (`p`)
    3. If the key is small, substitute left child for seleted node(`p`) : Search left
    4. If the key is large, substitute right child for seleted node(`p`) : Search right
    5. return to no 1

```c
/*--- Search ---*/
BinNode *Search(BinNode *p, const Member *x)
{
	int cond;
	if (p == NULL)
		return NULL;    /* search fail */	
	else if ((cond = MemberNoCmp(x, &p->data)) == 0)
		return p;       /* search sucess */                                          
	else if (cond < 0)
		Search(p->left, x);     /* search in left sub tree*/                             
	else
		Search(p->right, x);    /* search in right sub tree*/                  
}
```

---

#### Add Node
Note that after inserting a node, the shape of the tree must maintain the condition of the binary search tree. If key value of inserting node equal key vlaue of already exist node, should not insert node. 



* Conditional processing
    1. Substitute root for `p`(select root)
    2. If key value of inserting node equal key vlaue of already exist node : Insert fail
    3. Key value of Inserting node small than key value of `p`
        * `p` node has left child node
            move to left child node(substitute left child node pointer for selected node)
        * `p` node hasn't left child node
            insert node
    4. Key value of Inserting node large than key value of `p`
        * `p` node has right child node
            move to right child node(substitute right child node pointer for selected node)
        * `p` node hasn't right child node
            insert node
    5. return to no 2


```c
/*--- Add node ---*/
BinNode *Add(BinNode *p, const Member *x)
{
	int cond;
	if (p == NULL) {
		p = AllocBinNode();		
		SetBinNode(p, x, NULL, NULL);
	}
	else if ((cond = MemberNoCmp(x, &p->data)) == 0)
		printf("【Error】 %d is already exist.\n", x->no);
	else if (cond < 0)
		p->left = Add(p->left, x);
	else
		p->right = Add(p->right, x);
	return p;
}
```

---

#### Remove node

